#!/usr/bin/perl

# Implements ctf(1), defined separately.

use strict;
use warnings FATAL => 'all';

use File::Find::Object;
use File::Spec::Functions; # catfile
use Getopt::Long qw( :config bundling no_ignore_case require_order );
use IPC::Run qw(run);
use List::MoreUtils qw(any zip);
use Pod::Usage;
use Readonly;
use YAML;

my $root = $< == 0;

Readonly my $DFLT_CF => $root ? "/etc/ctf/ctf.conf" : "$ENV{HOME}/.ctf.conf";

my %conf = (
    contentdir => ($root ? "/var/lib/ctf/content" : "$ENV{HOME}/.ctf/content"),
    lockpath => $root ? "/var/lib/ctf/lock" : "$ENV{HOME}/.ctf/lock",
    disablepath => $root ? "/var/lib/ctf/disable" : "ENV{HOME}/.ctf/disable",
);

my $opt_cf;
my $test = 0;
my $opt_pre = 0;
my $opt_no_pre = 0;
my $opt_no_post = 0;
my @comp;
my @comploc;
my $opt_safe = 0;
my $opt_content;
my $opt_test;

GetOptions(
    'c|config=s' => \$opt_cf,
    't|test' => \$test,
    'P|nopre' => \$opt_no_pre,
    'T|nopost' => \$opt_no_post,
    'comp=s' => \@comp,
    'comp-loc=s' => \@comploc,
    's|safe'     => \$opt_safe,
    'C|content=s' => \$opt_content,
) or die;

defined($opt_content) and $conf{contentdir} = $opt_content;

my %complocs_opt;

if (@comp or @comploc) {
    @comp == @comploc or fatl(64, "--comp and --comp-loc must be given "
        . "the same number of times, because they define a mapping.  --comp "
        . "was given " . scalar(@comp) . " times and --comp-loc was given "
        . scalar(@comploc) . " times");

    %complocs_opt = (zip @comp, @comploc);
}

my @selection = @ARGV;

my $pre = (!$opt_safe and !$opt_no_pre);
my $post = (!$opt_safe and !$opt_no_post and !$opt_test);

my $do_load_cf = defined($opt_cf) || -f $DFLT_CF;

my $cfyaml = {};

if ($do_load_cf) {
    my $cf = $opt_cf // $DFLT_CF;

    # Currently relying on unspecified behaviour, that YAML will raise
    # an exception with a descriptive message if it can't load the file.
    # <https://rt.cpan.org/Public/Bug/Display.html?id=72571>
    $cfyaml = YAML::LoadFile($cf);

    for (qw(contentdir lockpath disablepath)) {
        defined($cfyaml->{$_}) and $conf{$_} = $cfyaml->{$_};
    }
}

# default
$conf{manifest} = catfile($conf{contentdir}, "ctf.manifest");

if ($do_load_cf) {
    for (qw(manifest)) {
        defined($cfyaml->{$_}) and $conf{$_} = $cfyaml->{$_};
    }
}

# again, <https://rt.cpan.org/Public/Bug/Display.html?id=72571>
my $manifest;
eval {
    $manifest = YAML::LoadFile($conf{manifest});
};
if ($@) {
    my $explicitly_configured = defined($cfyaml->{manifest});
    if ($explicitly_configured) {
        die $@;
    }
    else {
        $manifest = [];
    }
}

my %mf_hash;
for (@$manifest) {
    my $path = $_->{path};
    defined($path) or fatl(78, $conf{manifest}
        . ": every entry in manifest must define path");
    defined($mf_hash{$path}) and fatl(78, $conf{manifest}
        . ": defined twice in manifest: $path\n");
    $mf_hash{$path} = $_;
}

my %compdirs = (
    root => catfile($conf{contentdir}, "root"),
    home => catfile($conf{contentdir}, "home"),
);
# Config file entries override defaults..
if (defined($cfyaml->{comp_locs})) {
    %compdirs = (%compdirs, %{$cfyaml->{comp_locs}});
}
# .. and command line options win.
if (%complocs_opt) {
    %compdirs = (%compdirs, %complocs_opt);
}

my %do_comps;

for my $comp (sort keys %compdirs) {
    # FIXME: Probably need to distinguish between explicitly conifgured 
    # ones, which should exist, and default values, which need not.
    $do_comps{$comp} = -d $compdirs{$comp};
}

if (! any { -d } values %compdirs) {
    warn "no possible component dirs exist under $conf{contentdir}; "
        . "these are:\n";
    for (sort keys %compdirs) {
        warn $compdirs{$_} . "\n";
    }
    exit 100;
}

my @under;

if (@ARGV) {
    @under = @ARGV;
}
else {
    @under = ("/");
}

my @files;

for my $comp (sort keys %compdirs) {
    if ($do_comps{$comp}) {
        chdir $compdirs{$comp} or die "$!: $compdirs{$comp}\n";

        my $tree = File::Find::Object->new({}, ".");
        while (my $r = $tree->next) {
            next if -d $r;
            if (-l $r) {
                warn "repo components can not contain symlinks: $r\n";
                exit 101;
            }
            if (! -f $r) {
                warn "repo components can only contain regular files: $r\n";
                exit 101;
            }
            push @files, {comp => $comp, relpath => $r};
        }
    }
}

for my $file (@$manifest) {
    # FIXME: confirm present (unless selection excludes it).
    # warn if not.
}

my @updated;

for my $file (@files) {
    # update, adding to @updated if changed
    my @rplc = qw(rplc -e);

    my $mfe = $mf_hash{filehash_to_manifest_path($file)};
    if (defined($mfe)) {
        my %mfe = %{$mfe};
        defined($mfe{mode}) and push @rplc, "-m", $mfe{mode};
        defined($mfe{owner}) and push @rplc, "-o", $mfe{owner};
        defined($mfe{group}) and push @rplc, "-g", $mfe{group};
        if (defined($mfe{'text-encoding'}) && $mfe{'text-encoding'} eq 'none') {
            push @rplc, "--no-text";
        }
    }

    push @rplc, filehash_to_fspath($file);

    run([@rplc], '<', filehash_to_content_location($file));

    # Want to run postctf from here (subject to deps), so that we
    # have minimal unapplied config, and can easily back out if a
    # postctf fails.
}

sub filehash_to_fspath {
    my ($file) = @_;

    $file->{comp} eq 'root' and 
        return canonpath(catfile("/", $file->{relpath}));
    $file->{comp} eq 'home' and 
        return canonpath(catfile($ENV{HOME}, $file->{relpath}));
    die;
}

sub filehash_to_content_location {
    my ($file) = @_;

    return catfile($conf{contentdir}, $file->{comp}, $file->{relpath});
}

sub filehash_to_manifest_path {
    my ($file) = @_;

    $file->{comp} eq 'root' and
        return canonpath(catfile("/", $file->{relpath}));
    $file->{comp} eq 'home' and 
        return canonpath(catfile('~', $file->{relpath}));
    die;
}

sub manifest_entry {
    my ($file, $manifest) = @_;

#    if ($file->
}

sub fatl {
    my ($exit, @msg) = @_;

    print STDERR "ctf: fatal: ", @msg, "\n";
    exit $exit;
}

# FIXME
# - what to do if two components end up specifying the same file
#   differently, eg ~/foo and /home/alice/foo.
# - validate all properties in the manifest?  Catches errors, but may
#   reduce extensibility for other apps
