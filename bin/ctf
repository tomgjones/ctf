#!/usr/bin/perl

# Implements ctf(1), defined separately.

use strict;
use warnings FATAL => 'all';

use Data::Dumper;
use File::Compare;
use File::Find::Object;
use File::Spec::Functions; # catfile
use File::stat;
use Getopt::Long qw( :config bundling no_ignore_case require_order );
use IPC::Run qw(run);
use List::MoreUtils qw(any zip pairwise);
use Pod::Usage;
use Readonly;
use Smart::Comments;
use YAML;

Readonly my $root => $< == 0;

Readonly my $DFLT_CF => $root ? "/etc/ctf/ctf.conf" : "$ENV{HOME}/.ctf.conf";
Readonly my @KNOWN_COMPS => qw(root home);

my %conf = (
    lockpath => $root ? "/var/lib/ctf/lock" : "$ENV{HOME}/.ctf/lock",
    disablepath => $root ? "/var/lib/ctf/disable" : "ENV{HOME}/.ctf/disable",
);

my $opt_cf;
my $test = 0;
my $opt_pre = 0;
my $opt_no_pre = 0;
my $opt_no_post = 0;
my $opt_safe = 0;
my $opt_content;
my $opt_test;
my $opt_dry_run;
my ($opt_home_src, $opt_home_dst, $opt_root_src, $opt_root_dst);

GetOptions(
    'c|config=s' => \$opt_cf,
    't|test' => \$test,
    'P|nopre' => \$opt_no_pre,
    'T|nopost' => \$opt_no_post,
    's|safe'     => \$opt_safe,
    'C|content=s' => \$opt_content,
    'n|dry-run' => \$opt_dry_run,
    'H|home-src=s' => \$opt_home_src,
    'I|home-dst=s' => \$opt_home_dst,
    'r|root-src=s' => \$opt_root_src,
    'R|root-dst=s' => \$opt_root_dst,
    'h|help' => sub { pod2usage(-exitval => 0) },
) or die;

Readonly my $cdir => defined($opt_content) ? $opt_content
    : $root ? "/var/lib/ctf/content"
    :         "$ENV{HOME}/.ctf/content";

my @selection = @ARGV;


my $pre = (!$opt_safe and !$opt_no_pre);
my $post = (!$opt_safe and !$opt_no_post and !$opt_test);

my $do_load_cf = defined($opt_cf) || -f $DFLT_CF;

my $cfyaml = {};

if ($do_load_cf) {
    my $cf = $opt_cf // $DFLT_CF;

    # Currently relying on unspecified behaviour, that YAML will raise
    # an exception with a descriptive message if it can't load the file.
    # <https://rt.cpan.org/Public/Bug/Display.html?id=72571>
    $cfyaml = YAML::LoadFile($cf);

    for (qw(contentdir lockpath disablepath)) {
        defined($cfyaml->{$_}) and $conf{$_} = $cfyaml->{$_};
    }
}

Readonly my %comp_src => (
    root => $opt_root_src // $cfyaml->{root}{src} // canonpath("$cdir/root"),
    home => $opt_home_src // $cfyaml->{home}{src} // canonpath("$cdir/home"),
);

Readonly my %comp_dst => (
    root => $opt_root_dst // $cfyaml->{root}{dst} // '/',
    home => $opt_home_dst // $cfyaml->{home}{dst} // canonpath($ENV{HOME}),
);

# default
$conf{manifest} = catfile($conf{contentdir}, "ctf.manifest");

if ($do_load_cf) {
    for (qw(manifest)) {
        defined($cfyaml->{$_}) and $conf{$_} = $cfyaml->{$_};
    }
}

# again, <https://rt.cpan.org/Public/Bug/Display.html?id=72571>
my $manifest;
eval {
    $manifest = YAML::LoadFile($conf{manifest});
};
if ($@) {
    my $explicitly_configured = defined($cfyaml->{manifest});
    if ($explicitly_configured) {
        die $@;
    }
    else {
        $manifest = [];
    }
}

my %mf_hash;
for (@$manifest) {
    my $path = $_->{path};
    defined($path) or fatl(78, $conf{manifest}
        . ": every entry in manifest must define path");
    defined($mf_hash{$path}) and fatl(78, $conf{manifest}
        . ": defined twice in manifest: $path\n");
    $mf_hash{$path} = $_;
}

for my $k (keys %comp_src, keys %comp_dst) {
    if (! grep { $k eq $_ } @KNOWN_COMPS) {
        fatl(1, "unknown component: $k");
        # Okay but we should tell the user whether the bad data came from
        # the config file or a command line option.
    }
}

my %do_comps;

for my $comp (sort keys %comp_src) {
    # FIXME: Probably need to distinguish between explicitly conifgured 
    # ones, which should exist, and default values, which need not.
    # IOW, if I'm just managing my dotfiles under ~, I don't need to
    # have the input directory for the root component exist at all, but
    # if I've asked for root component to come from somewhere, then that
    # place should exist.  Summary of this comment needs to go into the
    # interface spec, after which most of it can be deleted!
    $do_comps{$comp} = -d $comp_src{$comp};
}

if (! any { -d } values %comp_src) {
    warn "no possible component dirs exist; "
        . "these are:\n";
    for (sort keys %comp_src) {
        warn $comp_src{$_} . "\n";
    }
    exit 100;
}

my @pfixes;

if (@ARGV) {
    @pfixes = @ARGV;
}
else {
    @pfixes = ("/");
}

my @files;
for my $pfix (@pfixes) {
    for my $comp (sort keys %comp_src) {
        my $dst_under_pfix = path_under($comp_dst{$comp}, $pfix);

        my $findpath_within_comp = defined($dst_under_pfix)
            ? "" 
            : path_under($pfix, $comp_dst{$comp});

        if ($do_comps{$comp} && defined($findpath_within_comp)) {

            my $findpath = canonpath("$comp_src{$comp}/$findpath_within_comp");
            
            my $tree = File::Find::Object->new({}, $findpath);

            while (my $p = $tree->next) {
                next if -d $p;
                if (-l $p) {
                    warn "repo components can not contain symlinks: $p\n";
                    exit 101;
                }
                if (! -f $p) {
                    warn "repo components can only contain regular files: $p\n";
                    exit 101;
                }

                my $path_within_comp = path_under($p, $comp_src{$comp});
                $path_within_comp // die;

                my $dstpath = canonpath("$comp_dst{$comp}/$path_within_comp");

                push @files, {
                   comp    => $comp,
                   dstpath => $dstpath,
                   srcpath => $p,
                };
            }
        }
    }
}

for my $file (@$manifest) {
    # FIXME: confirm present (unless selection excludes it).
    # warn if not.
}

my @updated;

FILE: for my $file (@files) {
    # update, adding to @updated if changed
    my @rplc = qw(rplc -e);
    my $mfe = $mf_hash{filehash_to_manifest_path($file)};

    ischange($file->{dstpath}, $file->{srcpath}, $mfe // {}) or next FILE;

    if (defined($mfe)) {
        my %mfe = %{$mfe};
        defined($mfe{mode}) and push @rplc, "-m", $mfe{mode};
        defined($mfe{owner}) and push @rplc, "-o", $mfe{owner};
        defined($mfe{group}) and push @rplc, "-g", $mfe{group};

        if (defined($mfe{'text-encoding'}) && $mfe{'text-encoding'} eq 'none') {
            push @rplc, "--no-text";
        }
    }

    $opt_dry_run and push @rplc, "-n";

    push @rplc, $file->{dstpath};

    run([@rplc], '<', $file->{srcpath});

    # FIXME: check for failure

    # Want to run postctf from here (subject to deps), so that we
    # have minimal unapplied config, and can easily back out if a
    # postctf fails.
}

sub filehash_to_manifest_path {
    my ($file) = @_;

    $file->{comp} eq 'root' and
        return canonpath(catfile("/", $file->{relpath}));
    $file->{comp} eq 'home' and 
        return canonpath(catfile('~', $file->{relpath}));
    die;
}

sub manifest_entry {
    my ($file, $manifest) = @_;

#    if ($file->
}

# If $lower is under $higher (on path strings alone, not on looking at
# the filesystem), then returns the path to reach $lower from $higher.
# Otherwise returns the empty list in list context, or undef in scalar
# context.
sub path_under {
    my ($lower, $higher) = @_;

    my @lower = split('/+', canonpath($lower));
    my @higher = split('/+', canonpath($higher));

    @lower < @higher and return;

# This was producing a warning 'Name "main::a" used only once: possible typo'
#    pairwise { defined($b) or return 1; $a eq $b or return; } @lower, @higher;

    for (my $i = 0; $i <= $#lower; $i++) {
        defined($higher[$i]) or return catfile(@lower[$i..$#lower]);
        $lower[$i] eq $higher[$i] or return;
    }

    return $lower[$#lower];
}


# Say we want to know the path, within each of the components,
# to /home/bob/foo.  Within root, it's /home/bob/foo.  Within home
# it's foo.
sub path_to_pfix_within_comp {
    my ($path, $comp, $comp_dst) = @_;

    if (!is_under($path, $comp_dst->{$comp})) {
        die;
    }

    
}

# It would be less code to let rplc do all this work, but the program
# was taking ~ 1 sec just for a few tens of files, so this is a 
# worthwhile optimisation.  Plus we don't cause so many writes, which
# has other advantages.
sub ischange {
    my ($path, $replacementpath, $meta) = @_;

    -f $path or return 1;

    defined(my $st = stat($path)) or fatl("$!: $path");

    if (defined($meta->{mode}) && oct($meta->{mode}) != ($st->mode & 07777)) {
        return 1;
    }
    
    if (defined($meta->{owner})) {
        my $uid = getpwnam($meta->{user});
        defined($uid) or fatl("$meta->{user}: $!");
        $uid == $st->uid or return 1;
    }

    if (defined($meta->{group})) {
        defined(my $gid = getgrnam($meta->{group})) 
            or fatl("$meta->{group}: $!");
        $gid == $st->gid or return 1;
    }

    compare($path, $replacementpath) and return 1;

    return;
}

sub fatl {
    my ($exit, @msg) = @_;

    print STDERR "ctf: fatal: ", @msg, "\n";
    exit $exit;
}

# FIXME
# - what to do if two components end up specifying the same file
#   differently, eg ~/foo and /home/alice/foo.
# - validate all properties in the manifest?  Catches errors, but may
#   reduce extensibility for other apps
# - not currently setting mode correctly for ~/bin/morning
# - -n mode doesn't work - it still deploys
# - may still be too fragile with binary files, eg a vim .swp file was
#   lying around, this made it fall over.  Maybe if diff exits 2, use
#   cmp instead


=head1 NAME ctf - deploy configuration files

Please see separate definition of interface in doc/ctf; this POD
is only here for pod2usage's sake to easily generate help text.

=head1 SYNOPSIS

  ctf [OPTIONS] [PATH ...]

  Deploy config files under PATHs, or all if no PATH is given.

  OPTIONS
  -c,--content=DIR specify content directory
