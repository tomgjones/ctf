#!/usr/bin/perl

# Implements ctf(1), defined separately.

use strict;
use warnings FATAL => 'all';

use File::Find::Object;
use File::Spec::Functions; # catfile
use Getopt::Long;
use List::MoreUtils qw(any zip);
use Pod::Usage;
use Readonly;
use YAML;

Readonly my $DFLT_CF = "/etc/ctf/ctf.conf";

my %conf = (
    contentdir => "/var/lib/ctf/content";
    lockpath = "/var/lock/ctf/lock";
    disablepath = "/var/lib/ctf/disable";
);

my $opt_cf;
my $test = 0;
my $opt_pre = 0;
my $opt_no_pre = 0;
my $opt_no_post = 0;
my @comp;
my @comploc;

GetOptions(
    'c|config=s' => \$opt_cf,
    't|test' => \$test,
    'p|pre' => \$opt_prectf,
    'P|nopre' => \$opt_no_pre,
    'T|nopost' => \$opt_no_post,
    'comp=s' => \@comp,
    'comp-loc=s' => \@comploc,
);

my %complocs_opt = (
    root => catfile($conf{contentdir}, "root"),
    home => catfile($conf{contentdir}, "home"),
);

if (@comp or @comploc) {
    @comp == @comploc or fatl(64, "--comp and --comp-loc must be given "
        . "the same number of times, because they define a mapping.  --comp "
        . "was given " . scalar(@comp) . " times and --comp-loc was given "
        . scalar(@comploc) . " times");

    %complocs_opt = zip @comp @comploc;
}

my @selection = @ARGV;

my $pre = ($test && $opt_pre) or (! $opt_no_pre);
my $post = !$opt_no_post;

my $do_load_cf = defined($opt_cf) || -f $DFLT_CF;

my $cfyaml = {};

if ($do_load_cf) {
    my $cf = $opt_cf // $DFLT_CF;
    $cfyaml = YAML::LoadFile($cf);

    for (qw(contentdir lockpath disablepath)) {
        defined($cfyaml->{$_}) and $conf{$_} = $cfyaml->{$_};
    }
}

# default
$conf{manifest} = catfile($conf{contentdir}, "ctf.manifest");

if ($do_load_cf) {
    for (qw(manifest)) {
        defined($cfyaml->{$_}) and $conf{$_} = $cfyaml->{$_};
    }
}

my $manifest = YAML::LoadFile($conf{manifest});
# TODO: if not explicitly configured, and manifest doesn't exist, treat
# as empty manifest.

my %mf_hash;
for (@$manifest) {
    my $path = $_->{path};
    defined($path) or fatl(78, $conf{manifest}
        . ": every entry in manifest must define path");
    defined($mf_hash->{$path}) and fatl(78, $conf{manifest}
        . ": defined twice in manifest: $path\n");
    $mf_hash->{$path} = $_;
  }

my %compdirs = (
    root => catfile($conf{contentdir}, "root"),
    home => catfile($conf{contentdir}, "home"),
);
# Config file entries override defaults..
if (defined($cfyaml->{comp_locs})) {
    %compdirs = (%compdirs, %{$cfyaml->{comp_locs}});
}
# and command line options win.
if (%complocs_opt) {
    %compdirs = (%compdirs, %complocs_opt);
}

my %do_comps;

for my $comp (sort keys %compdirs) {
    $do_comps{$comp} = -d $compdirs{$comp};
}

if (! any { -d } values %compdirs) {
    warn "no possible component dirs exist under $conf{contentdir}; "
        . "these are:\n";
    for (sort keys %compdirs) {
        warn $compdirs{$_} . "\n";
    }
    exit 100;
}

if (@ARGV) {
    # only look 
}
# ELSE
for my $comp (sort keys %compdirs) {
    if ($do_comps{$comp}) {
        chdir $compdirs{$comp} or die "$!: $compdirs{$comp}\n";

        my $tree = File::Find::Object->new({}, ".");
        while (my $r = $tree->next) {
            next if -d $r;
            if (-l $r) {
                warn "repo components can not contain symlinks: $r\n";
                exit 101;
            }
            if (! -f $r) {
                warn "repo components can only contain regular files: $r\n";
                exit 101;
            }
            push @files, {comp => $comp, relpath => $r};
        }
    }
}

for my $file (@$manifest) {
    # confirm present (unless selection excludes it)
}

my @updated;

for my $file (@files) {
    # update, adding to @updated if changed
    run(['rplc', filehash_to_fspath($file)], '<', 
         filehash_to_content_location($file));
    # FIXME: how do we tell if it changed, is it from rplc's exit code?
    # This requires rplc's interface to be fully specified.

    # Want to run postctf from here (subject to deps), so that we
    # have minimal unapplied config, and can easily back out if a
    # postctf fails.
}

sub filehash_to_fspath {
    my ($file) = @_;

    $file->{comp} eq 'root' and return catfile("/", $file->{relpath});
    $file->{comp} eq 'home' and return catfile($ENV{HOME}, $file->{relpath});
    die;
}

sub filehash_to_content_location {
    my ($file) = @_;

    return catfile($conf{contentdir}, $file->{comp}, $file->{relpath});
}

sub filehash_to_manifest_path {
    my ($file) = @_;

    $file->{comp} eq 'root' and return catfile("/", $file->{relpath});
    $file->{comp} eq 'home' and return catfile('~', $file->{relpath});
    die;
}

sub manifest_entry {
    my ($file, $manifest) = @_;

#    if ($file->
}

sub fatl {
    my ($exit, @msg) = @_;

    print STDERR "ctf: fatal: ", @msg, "\n";
    exit $exit;
}
